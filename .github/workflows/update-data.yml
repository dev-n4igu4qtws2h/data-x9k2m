name: Update Trading Data

on:
  schedule:
    - cron: '*/15 * * * *'  # Alle 15 Minuten
  workflow_dispatch:  # Manueller Trigger

jobs:
  update-data:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install requests python-dateutil

      - name: Fetch and process all strategies
        env:
          NOTION_API_KEY: ${{ secrets.NOTION_API_KEY }}
          AS2_EURUSD_M5_DB_ID: ${{ secrets.AS2_EURUSD_M5_DB_ID }}
        run: |
          python3 << 'EOF'
          import requests
          import json
          import os
          from datetime import datetime, timedelta
          from dateutil import parser

          def fetch_notion_data(database_id, api_key):
              url = f"https://api.notion.com/v1/databases/{database_id}/query"
              headers = {
                  "Authorization": f"Bearer {api_key}",
                  "Content-Type": "application/json",
                  "Notion-Version": "2022-06-28"
              }

              all_results = []
              has_more = True
              start_cursor = None

              while has_more:
                  payload = {}
                  if start_cursor:
                      payload["start_cursor"] = start_cursor

                  response = requests.post(url, headers=headers, json=payload)
                  response.raise_for_status()
                  data = response.json()

                  all_results.extend(data.get('results', []))
                  has_more = data.get('has_more', False)
                  start_cursor = data.get('next_cursor')

              return {'results': all_results}

          def get_trade_date(trade):
              """Extract trade date from 'Close Date / Time' or fallback to 'Date'"""
              date_prop = trade.get('properties', {}).get('Close Date / Time', {})

              if not date_prop or 'date' not in date_prop:
                  date_prop = trade.get('properties', {}).get('Date', {})

              if date_prop and 'date' in date_prop and date_prop['date']:
                  date_data = date_prop['date']
                  trade_date_str = date_data.get('start')

                  if trade_date_str:
                      try:
                          clean_date = trade_date_str.split('T')[0]
                          return datetime.strptime(clean_date, '%Y-%m-%d')
                      except ValueError:
                          pass

              return None

          def get_profit(trade):
              """Calculate Final Profit = Net Profit + Swap + Commission"""
              properties = trade.get('properties', {})

              # Get Net Profit
              net_profit_prop = properties.get('Net Profit', {})
              net_profit = net_profit_prop.get('number') if 'number' in net_profit_prop else None

              # Get Swap
              swap_prop = properties.get('Swap', {})
              swap = swap_prop.get('number') if 'number' in swap_prop else None

              # Get Commission
              commission_prop = properties.get('Commission', {})
              commission = commission_prop.get('number') if 'number' in commission_prop else None

              # Calculate Final Profit if all values exist
              if net_profit is not None and swap is not None and commission is not None:
                  final_profit = net_profit + swap + commission
                  return final_profit

              return None

          def calculate_equity_curve(trades, start_date=None, end_date=None):
              """Calculate equity curve data points with dates"""
              # Filter trades by date if specified
              filtered_trades = []
              for trade in trades:
                  trade_date = get_trade_date(trade)
                  if trade_date:
                      if start_date and trade_date < start_date:
                          continue
                      if end_date and trade_date > end_date:
                          continue

                      profit = get_profit(trade)
                      if profit is not None:
                          filtered_trades.append({
                              'date': trade_date,
                              'profit': profit
                          })

              # Sort by date
              filtered_trades.sort(key=lambda x: x['date'])

              # Calculate cumulative equity
              equity_data = []
              cumulative = 0

              for trade in filtered_trades:
                  cumulative += trade['profit']
                  equity_data.append({
                      'date': trade['date'].strftime('%Y-%m-%d'),
                      'equity': round(cumulative, 2)
                  })

              return equity_data

          def process_strategy(database_id, api_key, strategy_name):
              print(f"\nProcessing {strategy_name}...")

              data = fetch_notion_data(database_id, api_key)
              trades = data.get('results', [])

              now = datetime.now()
              start_of_year = datetime(now.year, 1, 1)
              start_of_month = datetime(now.year, now.month, 1)

              if now.month == 1:
                  start_of_last_month = datetime(now.year - 1, 12, 1)
                  end_of_last_month = datetime(now.year, 1, 1) - timedelta(days=1)
              else:
                  start_of_last_month = datetime(now.year, now.month - 1, 1)
                  end_of_last_month = start_of_month - timedelta(days=1)

              start_of_week = now - timedelta(days=now.weekday())
              start_of_week = datetime(start_of_week.year, start_of_week.month, start_of_week.day)

              def calculate_stats(trade_list, start=None, end=None):
                  wins = 0
                  losses = 0

                  for trade in trade_list:
                      trade_date = get_trade_date(trade)
                      if not trade_date:
                          continue

                      if start and trade_date < start:
                          continue
                      if end and trade_date > end:
                          continue

                      # Check if trade is excluded from winrate calculation
                      exclude_prop = trade.get('properties', {}).get('Exclude', {})
                      is_excluded = exclude_prop.get('checkbox', False) if 'checkbox' in exclude_prop else False

                      if is_excluded:
                          continue

                      outcome_prop = trade.get('properties', {}).get('Outcome', {})
                      if outcome_prop and 'select' in outcome_prop and outcome_prop['select']:
                          outcome = outcome_prop['select']['name']
                          if outcome == 'Win':
                              wins += 1
                          elif outcome == 'Loss':
                              losses += 1

                  total = wins + losses
                  winrate = round((wins / total * 100), 1) if total > 0 else 0

                  return {
                      'wins': wins,
                      'losses': losses,
                      'total': total,
                      'winrate': winrate
                  }

              result = {
                  'overall': calculate_stats(trades),
                  'ytd': calculate_stats(trades, start_of_year),
                  'this_month': calculate_stats(trades, start_of_month),
                  'last_month': calculate_stats(trades, start_of_last_month, end_of_last_month),
                  'last_week': calculate_stats(trades, start_of_week),
                  'equity': {
                      'overall': calculate_equity_curve(trades),
                      'ytd': calculate_equity_curve(trades, start_of_year),
                      'this_month': calculate_equity_curve(trades, start_of_month),
                      'last_month': calculate_equity_curve(trades, start_of_last_month, end_of_last_month),
                      'last_week': calculate_equity_curve(trades, start_of_week)
                  },
                  'last_updated': datetime.utcnow().isoformat() + 'Z'
              }

              print(f"‚úÖ {strategy_name}:")
              print(f"   Overall: {result['overall']['wins']}W / {result['overall']['losses']}L = {result['overall']['winrate']}%")
              print(f"   Equity points (Overall): {len(result['equity']['overall'])}")
              print(f"   YTD: {result['ytd']['wins']}W / {result['ytd']['losses']}L = {result['ytd']['winrate']}%")
              print(f"   This Month: {result['this_month']['wins']}W / {result['this_month']['losses']}L = {result['this_month']['winrate']}%")

              if result['equity']['overall']:
                  print(f"   First equity point: {result['equity']['overall'][0]}")
                  print(f"   Last equity point: {result['equity']['overall'][-1]}")

              return result

          def fetch_signal_reference(database_id, api_key):
              """Fetch signal service reference data"""
              print(f"   Fetching from DB: {database_id}")
              data = fetch_notion_data(database_id, api_key)
              references = {}

              print(f"   Found {len(data.get('results', []))} entries")

              for entry in data.get('results', []):
                  props = entry.get('properties', {})

                  print(f"\n   üìù Entry properties: {list(props.keys())}")

                  # Parse date (format: 01/10/2025)
                  date_prop = props.get('Date', {})
                  print(f"   Date prop type: {date_prop.get('type', 'unknown')}")

                  if date_prop and 'title' in date_prop and date_prop['title']:
                      date_str = date_prop['title'][0]['plain_text']
                      print(f"   Date string: {date_str}")

                      # Parse DD/MM/YYYY
                      try:
                          day, month, year = date_str.split('/')
                          month_key = f"{year}-{month.zfill(2)}"  # e.g., "2025-10"
                          print(f"   Month key: {month_key}")

                          # Get winners
                          winners_prop = props.get('Winners', {})
                          winners = winners_prop.get('number', 0) if 'number' in winners_prop else 0

                          # Get losers
                          losers_prop = props.get('Losers', {})
                          losers = losers_prop.get('number', 0) if 'number' in losers_prop else 0

                          # Get datafeed difference
                          diff_prop = props.get('Datafeed Difference', {})
                          datafeed_diff = diff_prop.get('number', 0) if 'number' in diff_prop else 0

                          references[month_key] = {
                              'winners': winners,
                              'losers': losers,
                              'datafeed_diff': datafeed_diff
                          }

                          print(f"   ‚úÖ Added: {month_key} -> {winners}W/{losers}L (diff: {datafeed_diff})")
                      except Exception as e:
                          print(f"   ‚ùå Parse error: {e}")

              print(f"\n   Total references collected: {list(references.keys())}")
              return references

          def compare_with_reference(actual_stats, reference_data, month_key):
              """Compare actual stats with signal service reference"""
              if month_key not in reference_data:
                  return None

              ref = reference_data[month_key]
              expected_wins = ref['winners'] + ref['datafeed_diff']
              expected_losses = ref['losers']

              wins_match = actual_stats['wins'] == expected_wins
              losses_match = actual_stats['losses'] == expected_losses

              return {
                  'reference_wins': ref['winners'],
                  'reference_losses': ref['losers'],
                  'datafeed_diff': ref['datafeed_diff'],
                  'expected_wins': expected_wins,
                  'expected_losses': expected_losses,
                  'wins_match': wins_match,
                  'losses_match': losses_match,
                  'in_sync': wins_match and losses_match
              }

          # Process AS2 EURUSD M5
          as2_data = process_strategy(
              os.environ['AS2_EURUSD_M5_DB_ID'],
              os.environ['NOTION_API_KEY'],
              'AS2 EURUSD M5'
          )

          # Fetch signal reference data
          print(f"\nFetching signal service reference data...")
          reference_data = fetch_signal_reference(
              os.environ.get('SIGNAL_REFERENCE_DB_ID', '2ac482524f4580359865d6fb85fd5bd0'),
              os.environ['NOTION_API_KEY']
          )

          # Compare last month with reference
          now = datetime.now()
          if now.month == 1:
              last_month_key = f"{now.year - 1}-12"
          else:
              last_month_key = f"{now.year}-{str(now.month - 1).zfill(2)}"

          this_month_key = f"{now.year}-{str(now.month).zfill(2)}"

          as2_data['signal_accuracy'] = {
              'last_month': compare_with_reference(as2_data['last_month'], reference_data, last_month_key),
              'this_month': compare_with_reference(as2_data['this_month'], reference_data, this_month_key)
          }

          print(f"\nüìä Signal Accuracy Check:")
          if as2_data['signal_accuracy']['last_month']:
              ref = as2_data['signal_accuracy']['last_month']
              status = "‚úÖ In Sync" if ref['in_sync'] else "‚ö†Ô∏è Mismatch"
              print(f"   Last Month: {status}")
              print(f"   Reference: {ref['reference_wins']}W / {ref['reference_losses']}L")
              print(f"   Datafeed Diff: {ref['datafeed_diff']:+d}")
              print(f"   Expected: {ref['expected_wins']}W / {ref['expected_losses']}L")
              print(f"   Actual: {as2_data['last_month']['wins']}W / {as2_data['last_month']['losses']}L")

          # Save to JSON
          os.makedirs('data', exist_ok=True)

          with open('data/as2-eurusd-m5.json', 'w') as f:
              json.dump(as2_data, f, indent=2)

          print(f"\n‚úÖ Saved as2-eurusd-m5.json")

          EOF

      - name: Commit and push if changed
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add data/*.json
          git diff --quiet && git diff --staged --quiet || (git commit -m "Update trading data [automated]" && git push)
